# 实验报告
最开始实现`sys_get_time`，从外部调用传进来的地址是虚拟地址，翻译成物理地址的话，
按照地址的结构，都是某一页加上偏移，于是做在了`sys_get_time`内部，
后面发现好像使用地址翻译的地方还挺多，就转移到了`memory_set`里面，
方便利用它里面的`page_table`。


# 问答

1. 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？
    
    页表项，即`PageTableEntry`：
    1. 0-7, 8 bits, 标志位flags；
    2. 8-9, 2 bits ,保留位reserved
    3. 10 - 53, 44 bits, 物理页号ppn
    4. 54 - 63, 10 bits, 保留位reserved,
2. 缺页
    缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断，
    告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。

    - 请问哪些异常可能是缺页导致的？
    - 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。
   
    回答：
    1. 按需加载，初次加载的时候会缺页；虚拟内存可能将某段内存置换出去，再次访问的时候出现缺页。
    2. csr STVAL寄存器被被硬件自动设置为该出错的VA

    - 这样做有哪些好处？
    
    回答：按需加载可以减少不必要的内存申请和释放。虚拟内存可以根据热度提升利用率。

    - 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？
    - 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。
    
    回答：10GiB=10x1024x1024x1024 Byte，其中一帧大小4x1024 Byte，
         一个页表项需要一个 64bit，即 8 Byte，总计页表需要 20 MiB 左右内存。

    缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。

    - 此时页面失效如何表现在页表项(PTE)上？
    
    回答：当PageFault触发时，会传进来对应的va，
    我们可以找到对应的PTE，其V位，可以被标记为0。

3. 双页表与单页表

   为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说，
   用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。
   (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念 ，详情
   见 `KPTI <https://en.wikipedia.org/wiki/Kernel_page-table_isolation>`_ )


   - 在单页表情况下，如何更换页表？
   - 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）
   - 单页表有何优势？（回答合理即可）
   - 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？

   回答：
   1. 单页表情况下，用户态的页表，对于内核态数据只复制了部分页表。更换方式同样
      按照`satp CSR 格式要求`构造64位整数，将新复制的页表根结点物理页号填进去。
   2. PTE U标识位，设置为0。
   3. 系统函数/变量访问地址固定，减少查找符号表的必要。
   4. 程序切换时和内核态用户态切换时；与双页表一样。

